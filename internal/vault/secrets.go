package vault

import (
	"errors"
	"net/url"
)

var (
	ErrInvalidSecret = errors.New("invalid vault secret")
)

const (
	// PKI secret
	queryKeyAltNames  = "altNames"
	queryKeyIPSANs    = "ipSans"
	queryKeyOtherSANs = "otherSans"
	queryKeyTTL       = "ttl"

	// Static secret
	queryKeyCertKey       = "tlsCertKey"
	queryKeyPrivateKeyKey = "tlsPrivateKeyKey"
)

type StaticSecret struct {
	Path          string
	CertKey       string
	PrivateKeyKey string
}

func NewStaticSecret(path, certKey, privateKeyKey string) StaticSecret {
	return StaticSecret{
		Path:          path,
		CertKey:       certKey,
		PrivateKeyKey: privateKeyKey,
	}
}

func ParseStaticSecret(ref string) (StaticSecret, error) {
	parsed, err := url.Parse(ref)
	if err != nil {
		return StaticSecret{}, err
	}

	if parsed.Scheme != StaticSecretScheme {
		return StaticSecret{}, ErrInvalidSecret
	}

	path := parsed.Path
	certKey := parsed.Query().Get(queryKeyCertKey)
	privateKeyKey := parsed.Query().Get(queryKeyPrivateKeyKey)

	return NewStaticSecret(path, certKey, privateKeyKey), nil
}

func (s StaticSecret) String() string {
	v := url.Values{}

	if s.CertKey != "" {
		v.Add(queryKeyCertKey, s.CertKey)
	}

	if s.PrivateKeyKey != "" {
		v.Add(queryKeyPrivateKeyKey, s.PrivateKeyKey)
	}

	return (&url.URL{
		Scheme:   StaticSecretScheme,
		Path:     s.Path,
		RawQuery: v.Encode(),
	}).String()
}

// PKISecret is a wrapper to a certificate secret to be generated by Vault.
//
// This Vault-specific implementation corresponds with the K8s-specific
// implementation, utils.K8sSecret.
type PKISecret struct {
	AltNames   string
	CommonName string
	IPSANs     string
	OtherSANs  string
	TTL        string
}

// NewPKISecret creates a descriptor for a certificate to be generated via Vault's PKI API.
// The arguments correspond with inputs to the cert + key generation endpoint.
// https://www.vaultproject.io/api-docs/secret/pki#generate-certificate-and-key
func NewPKISecret(commonName, altNames, ipSANs, otherSANs, ttl string) PKISecret {
	return PKISecret{
		AltNames:   altNames,
		CommonName: commonName,
		IPSANs:     ipSANs,
		OtherSANs:  otherSANs,
		TTL:        ttl,
	}
}

// ParsePKISecret accepts an opaque string reference and returns a PKISecret. The expected format
// is vault://<common_name>?ttl=<ttl>&ipSans=<sans>... where "common_name", "ttl", etc.
// correlate with values accepted by Vault's PKI API. Plural vars are generally comma-delimited
// lists as described in the docs.
//
// https://www.vaultproject.io/api-docs/secret/pki
//
// Some components such as the issuer and issue are configured globally today.
// In the future, we could include those as additional query parameters.
func ParsePKISecret(ref string) (PKISecret, error) {
	parsed, err := url.Parse(ref)
	if err != nil {
		return PKISecret{}, err
	}

	if parsed.Scheme != PKISecretScheme {
		return PKISecret{}, ErrInvalidSecret
	}

	commonName := parsed.Host
	altNames := parsed.Query().Get(queryKeyAltNames)
	ipSANs := parsed.Query().Get(queryKeyIPSANs)
	otherSANs := parsed.Query().Get(queryKeyOtherSANs)
	ttl := parsed.Query().Get(queryKeyTTL)

	return NewPKISecret(commonName, altNames, ipSANs, otherSANs, ttl), nil
}

// String serializes a PKISecret into an opaque string that can later
// be parsed and restored to an equivalent PKISecret.
func (s PKISecret) String() string {
	v := url.Values{}
	if s.AltNames != "" {
		v.Add(queryKeyAltNames, s.AltNames)
	}
	if s.IPSANs != "" {
		v.Add(queryKeyIPSANs, s.IPSANs)
	}
	if s.OtherSANs != "" {
		v.Add(queryKeyOtherSANs, s.OtherSANs)
	}
	if s.TTL != "" {
		v.Add(queryKeyTTL, s.TTL)
	}

	return (&url.URL{
		Scheme:   PKISecretScheme,
		Host:     s.CommonName,
		RawQuery: v.Encode(),
	}).String()
}
