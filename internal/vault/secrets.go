package vault

import (
	"errors"
	"net/url"
	"strings"
)

var (
	ErrInvalidSecret = errors.New("invalid vault secret")
)

const (
	// PKI secret
	queryParamAltNames  = "altNames"
	queryParamIPSANs    = "ipSans"
	queryParamOtherSANs = "otherSans"
	queryParamTTL       = "ttl"

	// KV secret
	queryParamCertField       = "tlsCertField"
	queryParamPrivateKeyField = "tlsPrivateKeyField"
)

type KVSecret struct {
	Path            string
	CertField       string
	PrivateKeyField string
}

func NewKVSecret(path, certField, privateKeyField string) KVSecret {
	return KVSecret{
		Path:            path,
		CertField:       certField,
		PrivateKeyField: privateKeyField,
	}
}

func ParseKVSecret(ref string) (KVSecret, error) {
	parsed, err := url.Parse(ref)
	if err != nil {
		return KVSecret{}, err
	}

	if parsed.Scheme != KVSecretScheme {
		return KVSecret{}, ErrInvalidSecret
	}

	if !strings.HasPrefix(parsed.Path, "/") {
		return KVSecret{}, ErrInvalidSecret
	}

	path := parsed.Path
	certField := parsed.Query().Get(queryParamCertField)
	privateKeyField := parsed.Query().Get(queryParamPrivateKeyField)

	if certField == "" || privateKeyField == "" {
		return KVSecret{}, ErrInvalidSecret
	}

	return NewKVSecret(path, certField, privateKeyField), nil
}

func (s KVSecret) String() string {
	v := url.Values{}

	if s.CertField != "" {
		v.Add(queryParamCertField, s.CertField)
	}

	if s.PrivateKeyField != "" {
		v.Add(queryParamPrivateKeyField, s.PrivateKeyField)
	}

	return (&url.URL{
		Scheme:   KVSecretScheme,
		Path:     s.Path,
		RawQuery: v.Encode(),
	}).String()
}

// PKISecret is a wrapper to a certificate secret to be generated by Vault.
//
// This Vault-specific implementation corresponds with the K8s-specific
// implementation, utils.K8sSecret.
type PKISecret struct {
	AltNames   string
	CommonName string
	IPSANs     string
	OtherSANs  string
	TTL        string
}

// NewPKISecret creates a descriptor for a certificate to be generated via Vault's PKI API.
// The arguments correspond with inputs to the cert + key generation endpoint.
// https://www.vaultproject.io/api-docs/secret/pki#generate-certificate-and-key
func NewPKISecret(commonName, altNames, ipSANs, otherSANs, ttl string) PKISecret {
	return PKISecret{
		AltNames:   altNames,
		CommonName: commonName,
		IPSANs:     ipSANs,
		OtherSANs:  otherSANs,
		TTL:        ttl,
	}
}

// ParsePKISecret accepts an opaque string reference and returns a PKISecret. The expected format
// is vault://<common_name>?ttl=<ttl>&ipSans=<sans>... where "common_name", "ttl", etc.
// correlate with values accepted by Vault's PKI API. Plural vars are generally comma-delimited
// lists as described in the docs.
//
// https://www.vaultproject.io/api-docs/secret/pki
//
// Some components such as the issuer and issue are configured globally today.
// In the future, we could include those as additional query parameters.
func ParsePKISecret(ref string) (PKISecret, error) {
	parsed, err := url.Parse(ref)
	if err != nil {
		return PKISecret{}, err
	}

	if parsed.Scheme != PKISecretScheme {
		return PKISecret{}, ErrInvalidSecret
	}

	commonName := parsed.Host
	altNames := parsed.Query().Get(queryParamAltNames)
	ipSANs := parsed.Query().Get(queryParamIPSANs)
	otherSANs := parsed.Query().Get(queryParamOtherSANs)
	ttl := parsed.Query().Get(queryParamTTL)

	return NewPKISecret(commonName, altNames, ipSANs, otherSANs, ttl), nil
}

// String serializes a PKISecret into an opaque string that can later
// be parsed and restored to an equivalent PKISecret.
func (s PKISecret) String() string {
	v := url.Values{}
	if s.AltNames != "" {
		v.Add(queryParamAltNames, s.AltNames)
	}
	if s.IPSANs != "" {
		v.Add(queryParamIPSANs, s.IPSANs)
	}
	if s.OtherSANs != "" {
		v.Add(queryParamOtherSANs, s.OtherSANs)
	}
	if s.TTL != "" {
		v.Add(queryParamTTL, s.TTL)
	}

	return (&url.URL{
		Scheme:   PKISecretScheme,
		Host:     s.CommonName,
		RawQuery: v.Encode(),
	}).String()
}
